package org.elusive.sound.enveloppes.ui;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.File;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;

import org.elusive.main.xml.XMLException;
import org.elusive.main.xml.XmlTools;
import org.elusive.sound.enveloppes.Enveloppe;
import org.elusive.sound.enveloppes.PointSon;
import org.elusive.ui.menus.MenuTools;
import org.elusive.ui.tools.PopupListener;
import org.elusive.ui.tools.file.OpenSaveManager;

public class EnveloppePanel extends JPanel {

	private Enveloppe enveloppe;

	private ArrayList<PointSon> pointsSelectionnes;
	private ArrayList<PointSon> pointsPress;
	protected int frameMax = 100000;

	protected Dimension minDim = new Dimension(200, 60);

	protected Point lastPress = null;
	protected int decalageX = 0;
	protected int decalageY = 0;

	protected int decalageXmin = 0;
	protected int decalageXmax = 0;
	protected int decalageYmin = 0;
	protected int decalageYmax = 0;

	protected Cursor curseur_main = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR);

	public EnveloppePanel(Enveloppe env) {
		this.enveloppe = env;
		pointsSelectionnes = new ArrayList<PointSon>();
		pointsPress = new ArrayList<PointSon>();
		revalideFrameMax();
		initListeners();

		this.setBorder(BorderFactory.createLineBorder(Color.black));
		this.setMinimumSize(minDim);
		this.setSize(minDim);
		this.setPreferredSize(minDim);

		// **** OPEN + SAVE
		OpenSaveManager osm = new OpenSaveManager(this, null, ".env") {

			@Override
			public String save() {
				return XmlTools.toXML(enveloppe);
			}

			@Override
			public boolean open(String fileContent) {
				ArrayList<PointSon> pts = null;
				try {
					enveloppe = (Enveloppe) XmlTools.fromXML(fileContent);
				} catch (XMLException e) {
					JOptionPane.showMessageDialog(null, "Il s'est produit une erreur lors de la lecture du fichier XML (cf console). : " + e.getMessage(), "Erreur", JOptionPane.ERROR_MESSAGE);
					e.printStackTrace();
					return false;
				}
				pointsPress.clear();
				pointsSelectionnes.clear();

				EnveloppePanel.this.repaint();
				return true;

			}
		};
		osm.addToMaps(getInputMap(WHEN_IN_FOCUSED_WINDOW), getActionMap());

	}

	private void initListeners() {
		this.addMouseMotionListener(new MouseMotionListener() {
			@Override
			public void mouseMoved(MouseEvent e) {
				PointSon p = pointAround(e.getPoint());
				if (p != null) {
					EnveloppePanel.this.setCursor(curseur_main);
				} else {
					EnveloppePanel.this.setCursor(Cursor.getDefaultCursor());
				}
			}

			@Override
			public void mouseDragged(MouseEvent e) {
				Point pt = e.getPoint();
				decalageX = pt.x - lastPress.x;
				decalageY = pt.y - lastPress.y;

				decalageX = Math.min(decalageXmax, Math.max(decalageXmin, decalageX));
				decalageY = Math.min(decalageYmax, Math.max(decalageYmin, decalageY));

				for (int i = 0; i < pointsPress.size(); i++) {
					int x = pix2frame(frame2Pix(pointsPress.get(i).getX()) + decalageX);
					double y = pix2amplitude(amplitude2Pix(pointsPress.get(i).getY()) + decalageY);
					pointsSelectionnes.get(i).setLocation(x, y);
				}

				decalageX = 0;
				decalageY = 0;

				EnveloppePanel.this.repaint();
			}
		});

		this.addMouseListener(new MouseListener() {
			@Override
			public void mouseReleased(MouseEvent e) {
				for (PointSon p : pointsSelectionnes) {
					p.setLocation(p.getX() + pix2frame(decalageX), pix2amplitude(amplitude2Pix(p.getY()) + decalageY));
				}

				decalageX = 0;
				decalageY = 0;
				EnveloppePanel.this.repaint();
			}

			@Override
			public void mousePressed(MouseEvent e) {
				Point pt = e.getPoint();
				PointSon p = pointAround(pt);
				lastPress = pt;
				if (e.getButton() == MouseEvent.BUTTON1) {
					switch (e.getClickCount()) {
					case 2:
						PointSon nouveau = new PointSon(pix2frame(pt.x), pix2amplitude(pt.y));
						enveloppe.add(nouveau);
						pointsSelectionnes.clear();
						pointsSelectionnes.add(nouveau);
						break;
					default:
						if (p != null) {
							if (!e.isControlDown() && !pointsSelectionnes.contains(p)) {
								pointsSelectionnes.clear();
							}
							if (!pointsSelectionnes.contains(p)) {
								pointsSelectionnes.add(p);
							}
							if (e.isControlDown() && pointsSelectionnes.contains(p)) {
								pointsSelectionnes.remove(p);
							}
						} else {
							pointsSelectionnes.clear();
						}
					}

					// calcul des dï¿½calages min et max

					int minX = Integer.MAX_VALUE;
					int maxX = Integer.MAX_VALUE;
					double minY = Double.MAX_VALUE;
					double maxY = 0;
					pointsPress.clear();
					for (PointSon pp : pointsSelectionnes) {
						// System.out.println("pp = " + pp);
						// System.out.println("index : " + points.indexOf(pp));
						int blocGauche = getNextPointNonSelectionne(pp, false);
						int blocDroit = getNextPointNonSelectionne(pp, true);

						minX = Math.min(minX, pp.getX() - blocGauche);
						maxX = Math.min(maxX, blocDroit - pp.getX());
						minY = Math.min(minY, pp.getY());
						maxY = Math.max(maxY, pp.getY());
						pointsPress.add(new PointSon(pp));
					}

					// System.out.println("minX : " + minX + ", maxX : " +
					// maxX);
					// System.out.println("maxY : " + maxY + ", minY : " +
					// minY);

					decalageXmin = -frame2Pix(minX);
					decalageXmax = frame2Pix(maxX);
					decalageYmin = -amplitude2Pix(maxY);
					decalageYmax = EnveloppePanel.this.getHeight() - amplitude2Pix(minY);

					// System.out.println("decalageXmin : " + decalageXmin
					// + ", decalageXmax : " + decalageXmax);
					// System.out.println("decalageYmin : " + decalageYmin
					// + ", decalageYmax : " + decalageYmax);

					EnveloppePanel.this.repaint();
				}
			}

			@Override
			public void mouseExited(MouseEvent e) {
			}

			@Override
			public void mouseEntered(MouseEvent e) {
			}

			@Override
			public void mouseClicked(MouseEvent e) {
				Point pt = e.getPoint();
				PointSon p = pointAround(pt);
				if (p != null) {
					if (!e.isControlDown()) {
						pointsSelectionnes.clear();
						pointsSelectionnes.add(p);
					}
				} else if (e.getButton() != 3) {
					pointsSelectionnes.clear();
				}
			}
		});

		this.addMouseListener(new PopupListener() {
			@Override
			public JPopupMenu showMenu(MouseEvent e) {
				JMenuBar menuBar = new JMenuBar();
				JMenuItem item;

				JMenu menu = new JMenu("Edit");

				// ***************** SELECT ALL ******************* //
				item = new JMenuItem("Select all");
				item.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent arg0) {
						pointsSelectionnes.clear();
						for (PointSon p : enveloppe.getPoints() ) {
							pointsSelectionnes.add(p);
						}
						EnveloppePanel.this.repaint();
					}
				});
				menu.add(item);

				// ***************** DELETE SELECTED POINTS *******************
				// //
				item = new JMenuItem("Delete selected points");
				item.addActionListener(new ActionListener() {
					@Override
					public void actionPerformed(ActionEvent arg0) {
						for (PointSon p : pointsSelectionnes) {
							enveloppe.getPoints().remove(p);
						}
						pointsSelectionnes.clear();
						EnveloppePanel.this.repaint();
					}
				});
				menu.add(item);

				menuBar.add(menu);
				return MenuTools.menuBarToPopupMenu(menuBar);
			}
		});
	}

	private void revalideFrameMax() {
		if (!enveloppe.getPoints().isEmpty()) {
			frameMax = enveloppe.getPoints().get(enveloppe.getPoints().size() - 1).getX();
		}
	}

	public PointSon pointAround(Point pt) {
		for (PointSon p : enveloppe.getPoints()) {
			if (Math.abs(frame2Pix(p.getX()) - pt.x) < 5 && Math.abs(amplitude2Pix(p.getY()) - pt.y) < 5) {
				return p;
			}
		}

		return null;
	}

	private int getNextPointNonSelectionne(PointSon ps, boolean droite) {
		int pas = droite ? 1 : -1;
		for (int ind = enveloppe.getPoints().indexOf(ps) + pas; ind > 0 && ind < enveloppe.getPoints().size(); ind += pas) {
			PointSon p = enveloppe.getPoints().get(ind);
			if (!pointsSelectionnes.contains(p)) {
				return p.getX();
			}
		}

		return droite ? frameMax : 0;
	}

	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		Graphics2D g2 = (Graphics2D) g;

		g2.setColor(new Color(250, 200, 150));
		g2.fillRect(1, 1, getWidth() - 2, getHeight() - 2);

		if (enveloppe.isNegativeValuesAccepted()) {
			g2.setColor(Color.black);
			g2.drawLine(0, getHeight() / 2, getWidth(), getHeight() / 2);
		}

		if (!enveloppe.getPoints().isEmpty()) {
			frameMax = enveloppe.getPoints().get(enveloppe.getPoints().size() - 1).getX();
		}

		for (int p = 0; p < enveloppe.getPoints().size() - 1; p++) {
			PointSon p1 = enveloppe.getPoints().get(p);
			PointSon p2 = enveloppe.getPoints().get(p + 1);
			int decalageX1 = 0;
			int decalageY1 = 0;
			int decalageX2 = 0;
			int decalageY2 = 0;
			if (pointsSelectionnes.contains(p1)) {
				g2.setColor(Color.red);
				decalageX1 += decalageX;
				decalageY1 += decalageY;
			} else {
				g2.setColor(Color.black);
			}
			if (pointsSelectionnes.contains(p2)) {
				decalageX2 += decalageX;
				decalageY2 += decalageY;
			}
			g2.drawOval(frame2Pix(p1.getX()) - 2 + decalageX1, amplitude2Pix(p1.getY()) - 2 + decalageY1, 5, 5);
			g2.setColor(Color.black);
			g2.drawLine(frame2Pix(p1.getX()) + decalageX1, amplitude2Pix(p1.getY()) + decalageY1, frame2Pix(p2.getX()) + decalageX2, amplitude2Pix(p2.getY()) + decalageY2);
		}

	}

	public int frame2Pix(int f) {
		return f * (this.getWidth()) / frameMax;
	}

	public int pix2frame(int pix) {
		return (pix) * frameMax / (this.getWidth());
	}

	public int amplitude2Pix(double a) {
		return enveloppe.isNegativeValuesAccepted() ? (int) ((1 - a) * (this.getHeight() / 2)) : (int) ((1 - a) * (this.getHeight()));
	}

	public double pix2amplitude(int pix) {
		return enveloppe.isNegativeValuesAccepted() ? 1 - (pix) / (double) (this.getHeight() / 2) : 1 - (pix) / (double) (this.getHeight());
	}
}
