package org.elusive.ui.grille;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.KeyStroke;

import org.elusive.main.historique.ActionHistorique;
import org.elusive.main.historique.ActionHistoriqueMultiple;
import org.elusive.main.historique.History;
import org.elusive.main.historique.HistoryListener;
import org.elusive.main.historique.action.AjouteBloc;
import org.elusive.main.historique.action.AjouteEffet;
import org.elusive.main.historique.action.ColleBlocs;
import org.elusive.main.historique.action.SupprimeBloc;
import org.elusive.main.performance.MemoryStatus;
import org.elusive.main.properties.ElusiveProperties;
import org.elusive.main.tools.IOtools;
import org.elusive.main.xml.XMLException;
import org.elusive.main.xml.XmlTools;
import org.elusive.sound.analyse.Analyser;
import org.elusive.sound.blocs.Bloc;
import org.elusive.sound.blocs.BlocFichier;
import org.elusive.sound.blocs.BlocPositionne;
import org.elusive.sound.effets.Effet;
import org.elusive.sound.rythm.Rythm;
import org.elusive.sound.tempo.Tempo;
import org.elusive.sound.tools.SoundTools;
import org.elusive.ui.fenetre.BarreControle;
import org.elusive.ui.fenetre.ElusivePanel;
import org.elusive.ui.fenetre.Fenetre;
import org.elusive.ui.fenetre.ShowableMenuFrame;
import org.elusive.ui.tools.file.FileDrop;
import org.elusive.ui.tools.file.OpenSaveManager;

public class Grille implements HistoryListener {

	private static final int FRAMES_PER_SECOND = 44100;
	public static final File SAVE_DIRECTORY = new File("sauvegardes");

	public Fenetre fenetre;
	public BarreControle controles;

	private History history;
	private OpenSaveManager openSaveManager;
	private float[] clipboard = null;

	private ArrayList<BlocPositionne> blocs = null;
	private ArrayList<BlocPositionne> blocsSelectionnes = null;
	private ArrayList<String> blocsCopies = null;

	// Le rythme solitaire
	private Rythm rythm = new Rythm();

	public int nbLignes = 30;
	public int longueurLigne = FRAMES_PER_SECOND * 20; // nbFrames
	public JPanel panel = null; // le tout
	public Graduations graduations = null;
	private GrillePanel panelGrille = null;
	private JScrollBar scrollH = null;
	private JScrollBar scrollV = null;

	// le curseur
	public int curseur = 0;

	// Autres
	public static final int framesPerSecond = FRAMES_PER_SECOND;
	public static final int frameMax = framesPerSecond * 600; // morceau de 10
																// minutes max

	private static Tempo tempo = new Tempo(150d);
	private static float volume = 0.15f;

	public Grille(Fenetre fenetre, File sauvegarde) {
		grilleDepot = this;
		this.fenetre = fenetre;
		this.controles = fenetre.controles;
		reset(null);

		// Historique
		history = new History(true);
		history.addHistoriqueListener(this);

		// OpenSaveManger
		openSaveManager = new OpenSaveManager(getPanelGrille(), SAVE_DIRECTORY, ".elu") {
			@Override
			public String save() {
				ElusiveProperties.put(ElusiveProperties.KEY_PROJECT, openSaveManager.getSavedFile().getAbsolutePath());
				return Grille.this.save();
			}

			@Override
			public boolean open(String fileContent) {
				try {
					Grille.this.open(fileContent);
				} catch (XMLException e) {
					JOptionPane.showMessageDialog(Grille.this.getPanelGrille(), "Il s'est produit une erreur lors de la lecture du fichier XML (cf console).\n\n\n" + e.getMessage(), "Erreur",
							JOptionPane.ERROR_MESSAGE);
					System.err.println(e);
					return false;
				}
				ElusiveProperties.put(ElusiveProperties.KEY_PROJECT, openSaveManager.getSavedFile().getAbsolutePath());
				history.clear();
				return true;
			}
		};
		openSaveManager.open(sauvegarde);

		initPanel();

		// Drag and Drop
		new FileDrop(this.getPanelGrille(), new FileDrop.Listener() {
			public void filesDropped(File[] files) {
				for (File file : files) {
					try {
						File ressourceFile = IOtools.copyFileInDirectory(file, getResourcesDir());

						// Create bloc from ressource file
						Bloc bloc = new BlocFichier(ressourceFile);
						AjouteBloc action = new AjouteBloc(Grille.this, bloc);
						history.execute(action);
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		});

		// blocs.add(new BlocPositionne(new KarplusStrong(), 1, 0));
		// blocs.add(new BlocPositionne(new WhiteNoise(), 2, 0));
		// blocs.add(new BlocPositionne(new FMSynthetizer(), 3, 0));
		// blocs.add(new BlocPositionne(new AdditiveSynth(), 4, 0));

	}

	private void initPanel() {
		panel = new JPanel(new GridBagLayout());

		scrollH = new JScrollBar(JScrollBar.HORIZONTAL);
		scrollH.setFocusable(true);
		updateScrollH(0);

		int max = getPanelGrille().hauteurLigne * nbLignes;
		scrollV = new JScrollBar(JScrollBar.VERTICAL, 0, max / 5, 0, max);

		scrollH.addAdjustmentListener(new AdjustmentListener() {
			public void adjustmentValueChanged(AdjustmentEvent e) {
				panel.repaint();
			}
		});
		scrollV.addAdjustmentListener(new AdjustmentListener() {
			public void adjustmentValueChanged(AdjustmentEvent e) {
				panel.repaint();
			}
		});

		graduations = new Graduations(this);
		setPanelGrille(new GrillePanel(this));

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.fill = GridBagConstraints.HORIZONTAL;

		gbc.weightx = 1.;
		gbc.weighty = 0;
		panel.add(graduations, gbc);
		gbc.gridy = 1;
		gbc.weightx = 1;
		gbc.weighty = 1;
		gbc.fill = GridBagConstraints.BOTH;
		panel.add(getPanelGrille(), gbc);
		gbc.weightx = 0;
		gbc.weighty = 0;
		gbc.fill = GridBagConstraints.VERTICAL;
		gbc.gridx = 1;
		panel.add(scrollV, gbc);
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.gridx = 0;
		gbc.gridy = 2;
		panel.add(scrollH, gbc);
		getPanelGrille().setBorder(BorderFactory.createLineBorder(Color.black));
		panel.setBorder(BorderFactory.createLineBorder(Color.black));
		// panel.setMinimumSize(dim);
		// panel.setPreferredSize(dim);
	}

	public JPanel getPanel() {
		return panel;
	}

	public int getSrollVValue() {
		return scrollV.getValue();
	}

	public void repaint() {
		// panel.paintImmediately(new Rectangle(panel.getSize()));
		if( panel != null ){
			panel.repaint();
		}
	}

	public ArrayList<BlocPositionne> getBlocs() {
		return blocs;
	}

	public ArrayList<BlocPositionne> getBlocsSelectionnes() {
		return blocsSelectionnes;
	}

	public boolean ajoutable(BlocPositionne bp) {
		return ajoutable(bp, blocs);
	}

	public boolean ajoutable(BlocPositionne bp, ArrayList<BlocPositionne> blocsPositionnes) {
		return ajoutable(bp.getLigne(), bp.getDebut(), bp.getFin(), blocsPositionnes);
	}

	public boolean ajoutable(int ligne, int debut, int fin, ArrayList<BlocPositionne> blocsFixes) {
		for (BlocPositionne b : blocsFixes) {
			if (b.getLigne() == ligne) {
				if (b.getDebut() < fin && b.getFin() > debut) {
					// ils se chevauchent
					return false;
				}
			}
		}
		return true;
	}

	public int getOffset() {
		int val = scrollH.getValue();
		int nbFramesParPixel = controles.getFramesPerPixel();
		if (nbFramesParPixel  > 0) {
			val *= nbFramesParPixel;
		} else {
			val /= (-nbFramesParPixel);
		}
		return val;
	}

	public void supprimeSelection() {
		if (!getBlocsSelectionnes().isEmpty()) {
			ActionHistoriqueMultiple action = new ActionHistoriqueMultiple("Supprime Blocs");
			for (BlocPositionne bp : this.getBlocsSelectionnes()) {
				action.addAction(new SupprimeBloc(this, bp));
			}
			this.history.execute(action);
		}
	}

	public void selecionneTout() {
		blocsSelectionnes = (ArrayList<BlocPositionne>) blocs.clone();
		panel.repaint();
	}

	public BlocPositionne newBloc(Bloc bloc) {
		int ligne = 0;
		int offset = curseur;
		if (getPanelGrille() != null) {
			Point lastClic = getPanelGrille().getLastClic();
			if (lastClic != null) {
				ligne = getPanelGrille().ligneAt(lastClic);
				offset = getPanelGrille().pixel2offset(lastClic.x);
			}
		}
		BlocPositionne bp = new BlocPositionne(this, bloc, ligne, offset, new ArrayList<Effet>());
		boolean b = newBloc(bp);
		if (b) {
			return bp;
		} else {
			return null;
		}
	}

	// On ajoute le bloc là où il "est", sinon sur une autre ligne
	public boolean newBloc(BlocPositionne bp) {
		boolean ret = false;
		if (ajoutable(bp)) {
			getBlocs().add(bp);
			ret = true;
		} else {
			int ligne = bp.getLigne();
			for (int l = ligne + 1; l != ligne; l++) {
				if (l >= nbLignes) {
					l = 0;
				}
				bp.setLigne(l);
				if (ajoutable(bp)) {
					getBlocs().add(bp);
					ret = true;
					break;
				}
			}
		}
		return ret;
	}

	// TODO : à déplacer dans l'UI
	public void updateScrollH(int oldCursorPixelPosition) {
		// il faut placer le curseur LA OU IL ETAIT, si possible.
		int off = curseur;

		int value = 0;
		int extent = 1;
		int min = 0;
		int max = frameMax;

		int unitIncrement = 10;

		int nbFramesPerPixel = controles.getFramesPerPixel();
		if (nbFramesPerPixel  > 0) {
			max /= nbFramesPerPixel;
			off /= nbFramesPerPixel;
		} else {
			max *= -nbFramesPerPixel;
			off *= -nbFramesPerPixel;
			unitIncrement = -nbFramesPerPixel;
		}

		if (getPanelGrille() != null) {
			value = off - oldCursorPixelPosition;
			if (nbFramesPerPixel < 0) {
				// il faut s'assurer qu'on commence sur une frame
				value -= value % (-nbFramesPerPixel);
			}
			if (value < 0) {
				value = 0;
			}
		}

		scrollH.setUnitIncrement(unitIncrement);
		scrollH.setBlockIncrement(10 * unitIncrement);
		int ancienneVal = scrollH.getValue();
		scrollH.setValues(value, extent, min, max);
		if (ancienneVal == value) {
			// il faut appeler un repaint car l'adjustment listener n'est pas
			// appelé
			// (cas où l'échelle passe de -1 à 1 et vice versa)
			repaint();
		}
	}

	public void copie() {
		System.out.println(" grille.copie()");
		blocsCopies.clear();
		for (BlocPositionne bp : blocsSelectionnes) {
			String xml = XmlTools.toXML(bp);
			System.out.println("*******************************COPIED :\n" + xml);
			blocsCopies.add(xml);
		}
	}

	public void colle() {
		if (!blocsCopies.isEmpty()) {
			int ligne = getPanelGrille().ligneAt(getPanelGrille().getLastClic());
			ActionHistorique ah = null;
			try {
				ah = new ColleBlocs(this, blocsCopies, curseur, ligne);
			} catch (XMLException e) {
				// NORMALEMENT IMPOSSIBLE car on a créé nous même l'XML...
				e.printStackTrace();
			}
			this.history.execute(ah);
		}
	}

	public void reset(ArrayList<BlocPositionne> blocs2) {
		blocs = blocs2;
		if (blocs == null) {
			blocs = new ArrayList<BlocPositionne>();
		}
		for(BlocPositionne bp : blocs){
//			System.out.println("bp "+bp+" setGrille");
			bp.setGrille(this);
		}
		blocsSelectionnes = new ArrayList<BlocPositionne>();
		blocsCopies = new ArrayList<String>();
	}

	public void setOffset(int newOffset) {
		if (newOffset < 0) {
			newOffset = 0;
		}
		int val = newOffset;
		int nbFramesPerPixel = controles.getFramesPerPixel();
		if (nbFramesPerPixel  > 0) {
			val /= nbFramesPerPixel;
		} else {
			val *= (-nbFramesPerPixel);
		}
		scrollH.setValue(val);
		// updateScrollH();
	}

	public JScrollBar getScrollV() {
		return scrollV;
	}

	public void setScrollVValue(int newY) {
		scrollV.setValue(newY);
	}
	
	public JScrollBar getScrollH(){
		return scrollH;
	}
	
	public void setScrollHValue(int newH){
		scrollH.setValue(newH);
	}

	public static Tempo getTempo() {
		return tempo;
	}

	public static void setVolume(float volume) {
		Grille.volume = volume;
	}

	public static float getVolume() {
		return volume;
	}

	// Ajoute un hit au rythme solitaire, à l'endroit où se trouve le curseur
	public void hitRythm() {
		int decalage = fenetre.grillePlayer.isPlaying() ? -20000 : 0; // TODO :
																		// empirique...
		rythm.addHit(curseur + decalage);
	}

	public Rythm getRythm() {
		return rythm;
	}

	@Override
	public void afterAction() {
		repaint();
	}

	private static Grille grilleDepot;

	public static Grille getGrilleDepot() {
		return grilleDepot;
	}

	public void remove(BlocPositionne blocASupprimer) {
		blocs.remove(blocASupprimer);
		// TODO : enlever les panels

		fenetre.getPanelsManager().removeBloc(blocASupprimer);
//		JFrame frame = blocASupprimer.getElusivePanel().getFrame();
//		if (frame != null) {
//			if (frame == fenetre) {
//				fenetre.getPanelsManager().removeBloc(blocASupprimer);
//			} else {
//				frame.setVisible(false);
//			}
//		}
	}

	public void open(String fileContent) throws XMLException {
		ArrayList<BlocPositionne> blocs = (ArrayList<BlocPositionne>) XmlTools.fromXML(fileContent);
		this.reset(blocs);
		this.repaint();
	}

	public String save() {
		for (BlocPositionne bp : this.getBlocs()) {
			if (bp.getBloc() instanceof BlocFichier) {
				BlocFichier bf = (BlocFichier) bp.getBloc();
				if (bf.getFichier().getAbsolutePath().startsWith(IOtools.getTemporaryFolder().getAbsolutePath())) {
					// If temporary file : copy in resources dir
					try {
						File resourceFile = IOtools.copyFileInDirectory(bf.getFichier(), getResourcesDir());
						bf.setFichier(resourceFile);
						System.out.println("Fenetre.save() - file copied to resources : " + resourceFile);
					} catch (IOException e) {
						e.printStackTrace();
					}
				}
			}
		}

		String s = XmlTools.toXML(this.getBlocs());
		s = XmlTools.XML_HEADER + s;
		return s;
	}

	public OpenSaveManager getOpenSaveManager() {
		return openSaveManager;
	}

	public File getResourcesDir() {
		File resources = null;
		if (openSaveManager.getSavedFile() != null && openSaveManager.getSavedFile().getParent() != null) {
			resources = new File(openSaveManager.getSavedFile().getParent() + File.separator + "resources");
		} else {
			// need intern temp directory
			File dir = IOtools.getTemporaryFolder();
			resources = new File(dir.getAbsolutePath() + File.separator + "Elusive");

		}
		if (!resources.isDirectory()) {
			boolean b = resources.mkdir();
			if (!b) {
				System.err.println("Fenetre : couldn't mkdir the directory : " + resources);
				return null;
			}
		}
		return resources;

	}

	public History getHistorique() {
		return history;
	}

	public float[] getClipboard() {
		return clipboard;
	}

	public void setClipboard(float[] clipboard) {
		this.clipboard = clipboard;
	}

	public void setPanelGrille(GrillePanel panelGrille) {
		this.panelGrille = panelGrille;
	}

	public GrillePanel getPanelGrille() {
		return panelGrille;
	}

}
